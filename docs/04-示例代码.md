# 04-示例代码

## 完整服务端示例

### SSL Echo 服务器

文件：`examples/include/E1-SslEchoServer.cc`

```cpp
#include <iostream>
#include <csignal>
#include <atomic>
#include "galay-ssl/async/SslSocket.h"
#include "galay-ssl/ssl/SslContext.h"
#include <galay-kernel/kernel/Coroutine.h>

#ifdef USE_KQUEUE
#include <galay-kernel/kernel/KqueueScheduler.h>
using IOSchedulerType = galay::kernel::KqueueScheduler;
#elif defined(USE_EPOLL)
#include <galay-kernel/kernel/EpollScheduler.h>
using IOSchedulerType = galay::kernel::EpollScheduler;
#elif defined(USE_IOURING)
#include <galay-kernel/kernel/IOUringScheduler.h>
using IOSchedulerType = galay::kernel::IOUringScheduler;
#endif

using namespace galay::ssl;
using namespace galay::kernel;

std::atomic<bool> g_running{true};

void signalHandler(int) {
    g_running = false;
}

/**
 * @brief 处理单个客户端连接
 */
Coroutine handleClient(SslContext* ctx, GHandle handle) {
    SslSocket client(ctx, handle);
    client.option().handleNonBlock();

    // SSL握手（可能需要多轮）
    while (!client.isHandshakeCompleted()) {
        auto result = co_await client.handshake();
        if (!result) {
            auto& err = result.error();
            if (err.code() == SslErrorCode::kHandshakeWantRead ||
                err.code() == SslErrorCode::kHandshakeWantWrite) {
                continue;
            }
            co_await client.close();
            co_return;
        }
        break;
    }

    std::cout << "Client connected, SSL handshake completed" << std::endl;

    // Echo循环
    char buffer[4096];
    while (g_running) {
        auto recvResult = co_await client.recv(buffer, sizeof(buffer));
        if (!recvResult) {
            break;
        }

        auto& bytes = recvResult.value();
        if (bytes.size() == 0) {
            std::cout << "Client disconnected" << std::endl;
            break;
        }

        std::cout << "Received: " << bytes.toStringView() << std::endl;

        // 回显数据
        auto sendResult = co_await client.send(
            reinterpret_cast<const char*>(bytes.data()),
            bytes.size()
        );
        if (!sendResult) {
            break;
        }
    }

    co_await client.shutdown();
    co_await client.close();
}

/**
 * @brief SSL Echo服务器协程
 */
Coroutine sslEchoServer(IOSchedulerType* scheduler, SslContext* ctx, uint16_t port) {
    SslSocket listener(ctx);

    if (!listener.isValid()) {
        co_return;
    }

    listener.option().handleReuseAddr();
    listener.option().handleNonBlock();

    auto bindResult = listener.bind(Host(IPType::IPV4, "0.0.0.0", port));
    if (!bindResult) {
        std::cerr << "bind failed" << std::endl;
        co_return;
    }

    auto listenResult = listener.listen(128);
    if (!listenResult) {
        std::cerr << "listen failed" << std::endl;
        co_return;
    }

    std::cout << "SSL Echo Server listening on port " << port << std::endl;

    while (g_running) {
        Host clientHost;
        auto acceptResult = co_await listener.accept(&clientHost);
        if (!acceptResult) {
            continue;
        }
        std::cout << "New connection from " << clientHost.ip()
                  << ":" << clientHost.port() << std::endl;
        if (!scheduler->spawn(handleClient(ctx, acceptResult.value()))) {
            std::cerr << "spawn failed for client handler" << std::endl;
        }
    }

    co_await listener.close();
    std::cout << "Server stopped" << std::endl;
}

int main(int argc, char* argv[]) {
    if (argc < 4) {
        std::cerr << "Usage: " << argv[0] << " <port> <cert_file> <key_file>" << std::endl;
        return 1;
    }

    uint16_t port = static_cast<uint16_t>(std::stoi(argv[1]));
    std::string certFile = argv[2];
    std::string keyFile = argv[3];

    // 设置信号处理
    signal(SIGINT, signalHandler);
    signal(SIGTERM, signalHandler);
    signal(SIGPIPE, SIG_IGN);

    // 创建SSL上下文
    SslContext ctx(SslMethod::TLS_Server);
    if (!ctx.isValid()) {
        std::cerr << "Failed to create SSL context" << std::endl;
        return 1;
    }

    auto certResult = ctx.loadCertificate(certFile);
    if (!certResult) {
        std::cerr << "Failed to load certificate: " << certResult.error().message() << std::endl;
        return 1;
    }

    auto keyResult = ctx.loadPrivateKey(keyFile);
    if (!keyResult) {
        std::cerr << "Failed to load private key: " << keyResult.error().message() << std::endl;
        return 1;
    }

    // 创建调度器
    IOSchedulerType scheduler;
    scheduler.start();

    // 启动服务器
    scheduler.spawn(sslEchoServer(&scheduler, &ctx, port));

    // 等待退出
    std::cout << "Press Ctrl+C to stop server..." << std::endl;
    while (g_running) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    scheduler.stop();
    return 0;
}
```

运行方式：

```bash
./E1-SslEchoServer 8443 certs/server.crt certs/server.key
```

## 完整客户端示例

### SSL 客户端

文件：`examples/include/E2-SslClient.cc`

```cpp
#include <iostream>
#include "galay-ssl/async/SslSocket.h"
#include "galay-ssl/ssl/SslContext.h"
#include <galay-kernel/kernel/Coroutine.h>

#ifdef USE_KQUEUE
#include <galay-kernel/kernel/KqueueScheduler.h>
using IOSchedulerType = galay::kernel::KqueueScheduler;
#elif defined(USE_EPOLL)
#include <galay-kernel/kernel/EpollScheduler.h>
using IOSchedulerType = galay::kernel::EpollScheduler;
#elif defined(USE_IOURING)
#include <galay-kernel/kernel/IOUringScheduler.h>
using IOSchedulerType = galay::kernel::IOUringScheduler;
#endif

using namespace galay::ssl;
using namespace galay::kernel;

/**
 * @brief SSL客户端协程
 */
Coroutine sslClient(SslContext* ctx, const std::string& host, uint16_t port) {
    SslSocket socket(ctx);

    if (!socket.isValid()) {
        std::cerr << "Failed to create socket" << std::endl;
        co_return;
    }

    socket.option().handleNonBlock();
    socket.setHostname(host);  // 设置SNI

    std::cout << "Connecting to " << host << ":" << port << "..." << std::endl;

    // 连接服务器
    auto connectResult = co_await socket.connect(Host(IPType::IPV4, host, port));
    if (!connectResult) {
        std::cerr << "Connect failed: " << connectResult.error().message() << std::endl;
        co_await socket.close();
        co_return;
    }

    std::cout << "TCP connected, starting SSL handshake..." << std::endl;

    // SSL握手
    while (!socket.isHandshakeCompleted()) {
        auto result = co_await socket.handshake();
        if (!result) {
            auto& err = result.error();
            if (err.code() == SslErrorCode::kHandshakeWantRead ||
                err.code() == SslErrorCode::kHandshakeWantWrite) {
                continue;
            }
            std::cerr << "Handshake failed: " << err.message() << std::endl;
            co_await socket.close();
            co_return;
        }
        break;
    }

    std::cout << "SSL handshake completed!" << std::endl;

    // 发送测试消息
    std::string message = "Hello, SSL Server!";
    std::cout << "Sending: " << message << std::endl;

    auto sendResult = co_await socket.send(message.c_str(), message.size());
    if (!sendResult) {
        std::cerr << "Send failed: " << sendResult.error().message() << std::endl;
        co_await socket.close();
        co_return;
    }

    std::cout << "Sent " << sendResult.value() << " bytes" << std::endl;

    // 接收响应
    char buffer[4096];
    auto recvResult = co_await socket.recv(buffer, sizeof(buffer));
    if (!recvResult) {
        std::cerr << "Recv failed: " << recvResult.error().message() << std::endl;
    } else {
        auto& bytes = recvResult.value();
        std::cout << "Received: " << bytes.toStringView() << std::endl;
    }

    // 关闭连接
    co_await socket.shutdown();
    co_await socket.close();
    std::cout << "Connection closed" << std::endl;
}

int main(int argc, char* argv[]) {
    if (argc < 3) {
        std::cerr << "Usage: " << argv[0] << " <host> <port> [ca_cert]" << std::endl;
        return 1;
    }

    std::string host = argv[1];
    uint16_t port = static_cast<uint16_t>(std::stoi(argv[2]));
    std::string caCert = argc > 3 ? argv[3] : "";

    // 创建SSL上下文
    SslContext ctx(SslMethod::TLS_Client);
    if (!ctx.isValid()) {
        std::cerr << "Failed to create SSL context" << std::endl;
        return 1;
    }

    // 加载CA证书（可选）
    if (!caCert.empty()) {
        auto caResult = ctx.loadCACertificate(caCert);
        if (!caResult) {
            std::cerr << "Failed to load CA certificate: "
                      << caResult.error().message() << std::endl;
            return 1;
        }
        ctx.setVerifyMode(SslVerifyMode::Peer);
        std::cout << "Certificate verification enabled" << std::endl;
    } else {
        // 不验证服务器证书（仅用于测试）
        ctx.setVerifyMode(SslVerifyMode::None);
        std::cout << "Warning: Certificate verification disabled" << std::endl;
    }

    // 创建调度器
    IOSchedulerType scheduler;
    scheduler.start();

    // 启动客户端
    scheduler.spawn(sslClient(&ctx, host, port));

    // 等待完成
    std::this_thread::sleep_for(std::chrono::seconds(2));

    scheduler.stop();
    return 0;
}
```

运行方式：

```bash
# 不验证证书（测试）
./E2-SslClient localhost 8443

# 验证证书
./E2-SslClient localhost 8443 certs/ca.crt
```

## 单元测试示例

### SslContext 和 SslEngine 测试

文件：`test/T1-SslSocketTest.cc`

```cpp
#include "galay-ssl/async/SslSocket.h"
#include "galay-ssl/ssl/SslContext.h"
#include "galay-ssl/ssl/SslEngine.h"
#include "galay-ssl/common/Error.h"
#include <iostream>
#include <cassert>

using namespace galay::ssl;

// 测试 SslContext 创建
void testSslContextCreation() {
    SslContext serverCtx(SslMethod::TLS_Server);
    assert(serverCtx.isValid());

    SslContext clientCtx(SslMethod::TLS_Client);
    assert(clientCtx.isValid());

    SslContext tls12Ctx(SslMethod::TLS_1_2_Server);
    assert(tls12Ctx.isValid());

    SslContext tls13Ctx(SslMethod::TLS_1_3_Server);
    assert(tls13Ctx.isValid());

    std::cout << "✓ SslContext creation tests passed" << std::endl;
}

// 测试证书加载
void testCertificateLoading() {
    SslContext ctx(SslMethod::TLS_Server);

    // 测试加载不存在的证书
    auto result1 = ctx.loadCertificate("nonexistent.crt");
    assert(!result1.has_value());
    assert(result1.error().code() == SslErrorCode::kCertificateLoadFailed);

    // 测试加载存在的证书
    auto result2 = ctx.loadCertificate("certs/server.crt");
    assert(result2.has_value());

    // 测试加载私钥
    auto result3 = ctx.loadPrivateKey("certs/server.key");
    assert(result3.has_value());

    std::cout << "✓ Certificate loading tests passed" << std::endl;
}

// 测试验证模式
void testVerifyMode() {
    SslContext ctx(SslMethod::TLS_Client);

    ctx.setVerifyMode(SslVerifyMode::None);
    assert(ctx.isValid());

    ctx.setVerifyMode(SslVerifyMode::Peer);
    assert(ctx.isValid());

    ctx.setVerifyDepth(4);
    assert(ctx.isValid());

    std::cout << "✓ Verify mode tests passed" << std::endl;
}

// 测试密码套件配置
void testCipherConfiguration() {
    SslContext ctx(SslMethod::TLS_Server);

    auto result1 = ctx.setCiphers("HIGH:!aNULL:!MD5");
    assert(result1.has_value());

    SslContext tls13Ctx(SslMethod::TLS_1_3_Server);
    auto result2 = tls13Ctx.setCiphersuites(
        "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256"
    );
    assert(result2.has_value());

    std::cout << "✓ Cipher configuration tests passed" << std::endl;
}

// 测试 SslEngine
void testSslEngine() {
    SslContext ctx(SslMethod::TLS_Client);
    SslEngine engine(&ctx);

    assert(engine.isValid());
    assert(engine.handshakeState() == SslHandshakeState::NotStarted);

    auto result = engine.setHostname("example.com");
    assert(result.has_value());

    engine.setConnectState();
    assert(engine.isValid());

    std::cout << "✓ SslEngine tests passed" << std::endl;
}

// 测试 SslError
void testSslError() {
    SslError success;
    assert(success.isSuccess());
    assert(success.code() == SslErrorCode::kSuccess);

    SslError handshakeFailed(SslErrorCode::kHandshakeFailed);
    assert(!handshakeFailed.isSuccess());
    assert(!handshakeFailed.needsRetry());

    SslError wantRead(SslErrorCode::kHandshakeWantRead);
    assert(wantRead.needsRetry());

    SslError wantWrite(SslErrorCode::kHandshakeWantWrite);
    assert(wantWrite.needsRetry());

    std::cout << "✓ SslError tests passed" << std::endl;
}

// 测试移动语义
void testMoveSemantics() {
    SslContext ctx1(SslMethod::TLS_Server);
    assert(ctx1.isValid());

    SslContext ctx2(std::move(ctx1));
    assert(ctx2.isValid());
    assert(!ctx1.isValid());

    SslContext ctx3(SslMethod::TLS_Client);
    ctx3 = std::move(ctx2);
    assert(ctx3.isValid());
    assert(!ctx2.isValid());

    std::cout << "✓ Move semantics tests passed" << std::endl;
}

int main() {
    std::cout << "\n========================================" << std::endl;
    std::cout << "  galay-ssl Unit Tests" << std::endl;
    std::cout << "========================================\n" << std::endl;

    try {
        testSslContextCreation();
        testCertificateLoading();
        testVerifyMode();
        testCipherConfiguration();
        testSslEngine();
        testSslError();
        testMoveSemantics();

        std::cout << "\n========================================" << std::endl;
        std::cout << "  All tests passed!" << std::endl;
        std::cout << "========================================\n" << std::endl;
        return 0;
    } catch (const std::exception& e) {
        std::cerr << "\nTest failed: " << e.what() << std::endl;
        return 1;
    }
}
```

运行方式：

```bash
./T1-SslSocketTest
```

## 高级示例

### 带超时的客户端

```cpp
Coroutine clientWithTimeout(SslContext* ctx, const std::string& host, uint16_t port) {
    using namespace std::chrono_literals;

    SslSocket socket(ctx);
    socket.option().handleNonBlock();
    socket.setHostname(host);

    // 连接超时 3 秒
    auto conn = co_await socket.connect(Host(IPType::IPV4, host, port)).timeout(3s);
    if (!conn) {
        std::cerr << "Connect timeout or failed: " << conn.error().message() << std::endl;
        co_await socket.close();
        co_return;
    }

    // 握手
    while (!socket.isHandshakeCompleted()) {
        auto hs = co_await socket.handshake();
        if (!hs) {
            co_await socket.close();
            co_return;
        }
    }

    // 发送超时 2 秒
    std::string msg = "Hello";
    auto sent = co_await socket.send(msg.c_str(), msg.size()).timeout(2s);
    if (!sent) {
        std::cerr << "Send timeout: " << sent.error().message() << std::endl;
        co_await socket.close();
        co_return;
    }

    // 接收超时 5 秒
    char buf[1024];
    auto recv = co_await socket.recv(buf, sizeof(buf)).timeout(5s);
    if (!recv) {
        std::cerr << "Recv timeout: " << recv.error().message() << std::endl;
    } else {
        std::cout << "Received: " << recv.value().toStringView() << std::endl;
    }

    co_await socket.shutdown();
    co_await socket.close();
}
```

### Session 复用示例

```cpp
class SessionManager {
public:
    void saveSession(const std::string& host, SSL_SESSION* session) {
        if (m_session) {
            SSL_SESSION_free(m_session);
        }
        SSL_SESSION_up_ref(session);
        m_session = session;
        m_host = host;
    }

    SSL_SESSION* loadSession(const std::string& host) {
        if (m_host == host && m_session) {
            SSL_SESSION_up_ref(m_session);
            return m_session;
        }
        return nullptr;
    }

    ~SessionManager() {
        if (m_session) {
            SSL_SESSION_free(m_session);
        }
    }

private:
    std::string m_host;
    SSL_SESSION* m_session = nullptr;
};

Coroutine clientWithSessionReuse(SslContext* ctx, const std::string& host, uint16_t port) {
    static SessionManager sessionMgr;

    SslSocket socket(ctx);
    socket.option().handleNonBlock();
    socket.setHostname(host);

    // 尝试加载已保存的 session
    SSL_SESSION* session = sessionMgr.loadSession(host);
    if (session) {
        socket.setSession(session);
        SSL_SESSION_free(session);
        std::cout << "Attempting session reuse..." << std::endl;
    }

    auto conn = co_await socket.connect(Host(IPType::IPV4, host, port));
    if (!conn) {
        co_await socket.close();
        co_return;
    }

    while (!socket.isHandshakeCompleted()) {
        auto hs = co_await socket.handshake();
        if (!hs) {
            co_await socket.close();
            co_return;
        }
    }

    if (socket.isSessionReused()) {
        std::cout << "✓ Session reused successfully!" << std::endl;
    } else {
        std::cout << "New session created" << std::endl;
        SSL_SESSION* newSession = socket.getSession();
        if (newSession) {
            sessionMgr.saveSession(host, newSession);
            SSL_SESSION_free(newSession);
        }
    }

    // 通信...
    co_await socket.shutdown();
    co_await socket.close();
}
```

### ALPN 协商示例

```cpp
Coroutine clientWithALPN(SslContext* ctx, const std::string& host, uint16_t port) {
    // 配置 ALPN 协议列表
    ctx->setALPNProtocols({"h2", "http/1.1"});

    SslSocket socket(ctx);
    socket.option().handleNonBlock();
    socket.setHostname(host);

    auto conn = co_await socket.connect(Host(IPType::IPV4, host, port));
    if (!conn) {
        co_await socket.close();
        co_return;
    }

    while (!socket.isHandshakeCompleted()) {
        auto hs = co_await socket.handshake();
        if (!hs) {
            co_await socket.close();
            co_return;
        }
    }

    // 检查协商结果
    std::string alpn = socket.getALPNProtocol();
    std::string proto = socket.getProtocolVersion();
    std::string cipher = socket.getCipher();

    std::cout << "Protocol: " << proto << std::endl;
    std::cout << "Cipher: " << cipher << std::endl;
    std::cout << "ALPN: " << (alpn.empty() ? "none" : alpn) << std::endl;

    if (alpn == "h2") {
        std::cout << "Using HTTP/2" << std::endl;
        // HTTP/2 逻辑
    } else if (alpn == "http/1.1") {
        std::cout << "Using HTTP/1.1" << std::endl;
        // HTTP/1.1 逻辑
    }

    co_await socket.shutdown();
    co_await socket.close();
}
```
