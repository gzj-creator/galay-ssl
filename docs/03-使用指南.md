# 03-使用指南

## 项目结构

```text
galay-ssl/
├── galay-ssl/
│   ├── common/
│   │   ├── Defn.hpp            # SSL 枚举与基础类型
│   │   └── Error.h/cc          # SslError / SslErrorCode
│   ├── ssl/
│   │   ├── SslContext.h/cc     # SSL_CTX 配置与证书管理
│   │   └── SslEngine.h/cc      # 单连接 SSL 状态机（Memory BIO）
│   ├── module/
│   │   └── galay.ssl.cppm      # C++23 命名模块接口
│   └── async/
│       ├── SslSocket.h/cc      # 高层异步 SSL Socket
│       └── Awaitable.h/cc      # 握手/收发/关闭 Awaitable
├── examples/
│   ├── include/
│   │   ├── E1-SslEchoServer.cc
│   │   └── E2-SslClient.cc
│   └── import/
│       ├── E1-SslEchoServer.cc
│       └── E2-SslClient.cc
├── test/
│   └── T1-SslSocketTest.cc
├── benchmark/
│   ├── B1-SslBenchServer.cc
│   ├── B1-SslBenchClient.cc
│   └── SslStats.h/cc
└── docs/
```

## 模块介绍

### SslContext

头文件：`galay-ssl/ssl/SslContext.h`

`SslContext` 封装 OpenSSL 的 `SSL_CTX`，负责 TLS 全局配置和证书加载。一个 `SslContext` 可供多个连接共享。

#### 关键接口

| 接口 | 说明 |
|------|------|
| `SslContext(SslMethod)` | 创建 Client/Server/TLS1.2/TLS1.3/DTLS 上下文 |
| `loadCertificate()` / `loadCertificateChain()` | 加载证书 |
| `loadPrivateKey()` | 加载私钥并校验与证书匹配 |
| `loadCACertificate()` / `useDefaultCA()` | 配置信任根 |
| `setVerifyMode()` / `setVerifyDepth()` | 配置证书校验策略 |
| `setCiphers()` / `setCiphersuites()` | 配置密码套件 |
| `setALPNProtocols()` | 配置 ALPN 协议列表 |
| `setSessionCacheMode()` / `setSessionTimeout()` | 配置 Session 缓存 |

### SslEngine

头文件：`galay-ssl/ssl/SslEngine.h`

`SslEngine` 对应单条 TLS 连接，负责调用 OpenSSL 进行握手和加解密。它本身不直接做网络 IO，而是通过 Memory BIO 与外部 IO 层交换密文。

#### 关键职责

| 接口 | 说明 |
|------|------|
| `initMemoryBIO()` | 初始化 `rbio/wbio` |
| `setConnectState()` / `setAcceptState()` | 设置客户端/服务端模式 |
| `doHandshake()` | 执行非阻塞握手 |
| `read()` / `write()` | 处理明文读写（内部调用 SSL_read/SSL_write） |
| `feedEncryptedInput()` | 将网络密文写入 `rbio` |
| `extractEncryptedOutput()` | 从 `wbio` 取出待发送密文 |
| `pendingEncryptedOutput()` | 查询待发送密文大小 |
| `getProtocolVersion()` / `getCipher()` / `getALPNProtocol()` | 查询协商结果 |
| `getSession()` / `setSession()` / `isSessionReused()` | Session 复用能力 |

### SslSocket

头文件：`galay-ssl/async/SslSocket.h`

`SslSocket` 是面向业务的高层 API，内部组合 `IOController + SslEngine`，把 TCP + TLS 行为统一成协程友好接口。

#### 关键接口

| 接口 | 返回 | 说明 |
|------|------|------|
| `bind(host)` | `expected<void, IOError>` | 绑定地址 |
| `listen(backlog)` | `expected<void, IOError>` | 开始监听 |
| `accept(host*)` | `AcceptAwaitable` | 接收新连接 |
| `connect(host)` | `ConnectAwaitable` | 异步连接 |
| `handshake()` | `SslHandshakeAwaitable` | 执行 TLS 握手 |
| `recv(buf, len)` | `SslRecvAwaitable` | 异步读取明文 |
| `send(buf, len)` | `SslSendAwaitable` | 异步发送明文 |
| `shutdown()` | `SslShutdownAwaitable` | 执行 TLS 关闭握手 |
| `close()` | `CloseAwaitable` | 关闭底层 socket |

补充：`SslSocket` 不可拷贝、可移动；析构时不会自动关闭 fd，需显式 `co_await close()`。

### Awaitable 层

头文件：`galay-ssl/async/Awaitable.h`

#### 类型说明

| 类型 | 说明 |
|------|------|
| `SslHandshakeAwaitable` | 多轮握手状态机（RECV/SEND 任务编排） |
| `SslRecvAwaitable` | SSL 读状态机，处理 `WantRead/WantWrite` |
| `SslSendAwaitable` | SSL 写状态机，处理密文分块发送 |
| `SslShutdownAwaitable` | TLS 关闭握手状态机 |

#### 超时能力

- `accept/connect/recv/send/close` 支持 `.timeout()`
- `handshake/shutdown` 当前不提供 `.timeout()`

### 错误模型

头文件：`galay-ssl/common/Error.h`

- TLS 相关错误使用 `SslError`
- 系统 IO 相关错误使用 `IOError`（来自 `galay-kernel`）

常见 `SslErrorCode`：

- `kHandshakeFailed`
- `kHandshakeWantRead`
- `kHandshakeWantWrite`
- `kReadFailed`
- `kWriteFailed`
- `kPeerClosed`
- `kSNISetFailed`
- `kALPNSetFailed`

### Benchmark 与 Test

- `T1-SslSocketTest`：基础单元测试（`SslContext` / `SslEngine` / `SslError`）
- `B1-SslBenchServer`：SSL Echo 服务端压测程序
- `B1-SslBenchClient`：并发连接压测客户端（支持 `payload`、`threads`、`connect_retries`）
- `SslStats`：压测侧可选统计模块（`GALAY_SSL_STATS=1`）

## 使用示例

### SSL Echo 服务端

```cpp
#include "galay-ssl/async/SslSocket.h"
#include "galay-ssl/ssl/SslContext.h"
#include <galay-kernel/kernel/Coroutine.h>

using namespace galay::ssl;
using namespace galay::kernel;

Coroutine handleClient(SslContext* ctx, GHandle handle)
{
    SslSocket client(ctx, handle);
    client.option().handleNonBlock();

    while (!client.isHandshakeCompleted()) {
        auto hs = co_await client.handshake();
        if (!hs) {
            co_await client.close();
            co_return;
        }
    }

    char buffer[4096];
    while (true) {
        auto r = co_await client.recv(buffer, sizeof(buffer));
        if (!r || r.value().size() == 0) break;

        auto b = r.value();
        auto s = co_await client.send(reinterpret_cast<const char*>(b.data()), b.size());
        if (!s) break;
    }

    co_await client.shutdown();
    co_await client.close();
}

Coroutine runServer(IOScheduler* scheduler, SslContext* ctx, uint16_t port)
{
    SslSocket listener(ctx);
    listener.option().handleReuseAddr();
    listener.option().handleNonBlock();
    listener.bind(Host(IPType::IPV4, "0.0.0.0", port));
    listener.listen(1024);

    while (true) {
        Host peer;
        auto accepted = co_await listener.accept(&peer);
        if (!accepted) continue;
        scheduler->spawn(handleClient(ctx, accepted.value()));
    }
}
```

对应模块化导入版本文件：`examples/import/E1-SslEchoServer.cc`

### SSL 客户端（不校验证书，仅测试）

```cpp
Coroutine runClient(SslContext* ctx, const std::string& host, uint16_t port)
{
    SslSocket socket(ctx);
    socket.option().handleNonBlock();
    socket.setHostname(host);

    auto conn = co_await socket.connect(Host(IPType::IPV4, host, port));
    if (!conn) {
        co_await socket.close();
        co_return;
    }

    while (!socket.isHandshakeCompleted()) {
        auto hs = co_await socket.handshake();
        if (!hs) {
            co_await socket.close();
            co_return;
        }
    }

    std::string msg = "Hello, SSL Server!";
    if (auto __await_result = co_await socket.send(msg.c_str(), msg.size()); !__await_result) {
        // 错误处理：记录日志、重试或提前返回
    }

    char buf[1024];
    auto r = co_await socket.recv(buf, sizeof(buf));
    if (r && r.value().size() > 0) {
        std::cout << r.value().toStringView() << std::endl;
    }

    co_await socket.shutdown();
    co_await socket.close();
}

// 初始化上下文（测试模式）
SslContext ctx(SslMethod::TLS_Client);
ctx.setVerifyMode(SslVerifyMode::None);
```

对应模块化导入版本文件：`examples/import/E2-SslClient.cc`

### SSL 客户端（校验证书）

```cpp
SslContext ctx(SslMethod::TLS_Client);

auto ca = ctx.loadCACertificate("certs/ca.crt");
if (!ca) {
    std::cerr << ca.error().message() << std::endl;
    return;
}

ctx.setVerifyMode(SslVerifyMode::Peer);
ctx.setVerifyDepth(4);
```

### SNI + ALPN

```cpp
SslContext clientCtx(SslMethod::TLS_Client);
clientCtx.setVerifyMode(SslVerifyMode::Peer);
clientCtx.loadCACertificate("certs/ca.crt");

// ALPN（客户端和服务端都可以配置）
clientCtx.setALPNProtocols({"h2", "http/1.1"});

SslSocket socket(&clientCtx);
socket.setHostname("api.example.com");  // SNI

// 握手成功后读取协商结果
std::string proto = socket.getProtocolVersion();
std::string cipher = socket.getCipher();
std::string alpn = socket.getALPNProtocol();
```

### Session 复用

```cpp
SSL_SESSION* cached = nullptr;

// 第一次连接
{
    SslSocket c1(&ctx);
    if (auto __await_result = co_await c1.connect(Host(IPType::IPV4, "127.0.0.1", 8443)); !__await_result) {
        // 错误处理：记录日志、重试或提前返回
    }
    while (!c1.isHandshakeCompleted()) {
        auto hs = co_await c1.handshake();
        if (!hs) co_return;
    }

    cached = c1.getSession();  // 调用者负责释放
    co_await c1.shutdown();
    co_await c1.close();
}

// 第二次连接尝试复用
{
    SslSocket c2(&ctx);
    if (cached) {
        c2.setSession(cached);
    }

    if (auto __await_result = co_await c2.connect(Host(IPType::IPV4, "127.0.0.1", 8443)); !__await_result) {
        // 错误处理：记录日志、重试或提前返回
    }
    while (!c2.isHandshakeCompleted()) {
        auto hs = co_await c2.handshake();
        if (!hs) co_return;
    }

    bool reused = c2.isSessionReused();
    std::cout << "session reused: " << reused << std::endl;

    co_await c2.shutdown();
    co_await c2.close();
}

if (cached) {
    SSL_SESSION_free(cached);
}
```

### 超时示例

```cpp
using namespace std::chrono_literals;

auto conn = co_await socket.connect(Host(IPType::IPV4, "127.0.0.1", 8443)).timeout(3s);
if (!conn) {
    std::cerr << conn.error().message() << std::endl;
    co_return;
}

auto sent = co_await socket.send(data, len).timeout(2s);
if (!sent) {
    std::cerr << sent.error().message() << std::endl;
    co_return;
}

auto recv = co_await socket.recv(buf, sizeof(buf)).timeout(5s);
if (!recv) {
    std::cerr << recv.error().message() << std::endl;
    co_return;
}
```

### 压测示例

```bash
# 终端 1：服务端
./build/bin/B1-SslBenchServer 9443 certs/server.crt certs/server.key

# 终端 2：小包压测（47B）
./build/bin/B1-SslBenchClient 127.0.0.1 9443 200 500 47 4

# 大包压测（64KiB）
./build/bin/B1-SslBenchClient 127.0.0.1 9443 10 200 65536 1

# 启用 benchmark 侧 SSL IO 统计
GALAY_SSL_STATS=1 ./build/bin/B1-SslBenchClient 127.0.0.1 9443 50 200 47 4
```

`B1-SslBenchClient` 参数说明：

- `host`
- `port`
- `connections`
- `requests_per_conn`
- `payload_bytes`（可选，默认 47）
- `threads`（可选，默认 1）
- `connect_retries`（可选，默认 3）
